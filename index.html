<!DOCTYPE html>
<html>
<head>
  <title>Questionnaire</title>

  <!-- Load JsPsych -->
  <script src="https://unpkg.com/jspsych@7.3.4"></script>
  <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css" />

  <!-- Load Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1.1.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.2.0"></script> 
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@1.0.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-fullscreen@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey@1.0.1"></script>
  <link rel="stylesheet" href="https://unpkg.com/@jspsych/plugin-survey@1.0.1/css/survey.css"/>

  <!-- Additional Scripts -->
  <link rel="stylesheet" href="style.css">
  <script src = "trials.js"></script>
  <script src = "surveys.js"></script>

</head> 
<body> 
  <label>
    <input type="radio" name="choice" checked>
  </label>
</body>
<script>

let skipped_glob = []; 

// INITIATE JSPSYCH ================================================================

const jsPsych = initJsPsych({
  on_finish: function () {
    // const trials = jsPsych.data.get().filter({
    //   trial_section: 'task' // Only relevant pages included in custom calculations.
    // }).values();

  // NOW save (LOCAL TESTING ONLY)
  jsPsych.data.get().localSave('csv', 'debug_local.csv');
  //jsPsych.data.get().filter({trial_section: 'task'}).localSave('csv','task_only.csv')

  // Optional debug
  // console.log(jsPsych.data.get().values());
  jsPsych.data.displayData();
   }

});


// SUBJECT ID ================================================================
const subject_id = jsPsych.randomization.randomID(6);
const filename = `${subject_id}.csv`;

jsPsych.data.addProperties({ subject_id });


// ADD CUSTOM LOGIC ================================================================

function addSurveyLogic(trial) {

  trial.on_load = function() { // Runs everytime a trial is rendered.
    if (typeof trial.questions === "function") {
      trial.questions = trial.questions();
    }

    
    // PER PAGE TRACKING VARIABLES ================================================================
    window.last_question_time = performance.now(); 
    window.rt_data = {};
    window.acc_data = {}; 
    window.answered = {}; 
    window.page_start_time = performance.now();
    // window.click_log = [];
    // window.answer_click_count = {};
    // window.q_first_answer = {};
    // window.q_counter = 0;
    // window.answeredPlural = 0;
    
    trial.questions.forEach(q => { // Overwritten for each new page.
      window.answered[q.name] = false;
      window.rt_data[q.name] = null;
      window.acc_data[q.name] = null;
      // window.q_first_answer[q.name] = null;
    });
  

    // // Custom tracking logic via Event Listeners ------------------------------------------------

    setTimeout(() => {
      const radios = document.querySelectorAll("input[type='radio']");
      radios.forEach(radio => {
        radio.addEventListener("click", function(event) { // Attached event (i.e. a click) listeners to every radiobutton.
          let now = performance.now(); // Know which question was clicked by pasring radio input's name.

          const radioName = event.target.name;
          const allRadiosSameQuestion = document.querySelectorAll(
            `input[type="radio"][name="${radioName}"]`
          );

          allRadiosSameQuestion.forEach(r => {
            r.disabled = true;
          });

          const qIndex = parseInt(event.target.name.replace("jspsych-survey-multi-choice-response-",""));

          // Disable all EARLIER skipped questions
          for (let i = 0; i < qIndex; i++) {
            const earlierQ = trial.questions[i].name;

            if (!window.answered[earlierQ]) {
              const skippedRadios = document.querySelectorAll(
                `input[type="radio"][name="jspsych-survey-multi-choice-response-${i}"]`
              );

              skippedRadios.forEach(r => {
                r.disabled = true;
              });
            }
          }

          const qname = trial.questions[qIndex].name;

          const response = event.target.value;
   
          window.answered[qname] = true;

          window.rt_data[qname] = now - window.last_question_time;
          window.last_question_time = now;
    
          let base_qname = qname.endsWith("_retry") ? qname.replace("_retry", "") : qname;
          
          if (correctAnswers[base_qname] !== undefined) {
            window.acc_data[qname] =
            response === correctAnswers[base_qname]; 
        } else {
            window.acc_data[qname] = null;
        }

        // if (!window.answer_click_count[qname]) {
        //     window.answer_click_count[qname] = 0;
        //   }
        //   window.answer_click_count[qname]++;
  
        //   window.click_log.push({
        //     qname: qname,
        //     q_index: qIndex,
        //     t_from_page_start: now - window.page_start_time,
        //     click_number: window.answer_click_count[qname]
        //   });

        //   if (window.q_first_answer[qname] === null) {
        //   window.q_first_answer[qname] = now;
        // }

        // if (window.answer_click_count[qname] === 2) {
        //   window.answeredPlural++;
        // }
          
          }
        );  
      } 
    );
    }, 100); 
  };


  // ON FINISH ================================================================

  trial.on_finish = function(data) {
    
    data.submit_latency_from_last = performance.now() - window.last_question_time;
    // data.answered_plural = window.answeredPlural ?? 0;
    // if (data.answered_plural === undefined) {
    //   data.answered_plural = 0;
    // };

    trial.questions.forEach(q => {
      if(!window.answered[q.name]){
        window.rt_data[q.name] = null;
        window.acc_data[q.name] = null;
        skipped_glob.push({
          prompt: q.prompt,
          name: q.name + "_retry",
          original_name: q.name,
          options: q.options
        });
      }
    });

    data.rt_per_question = window.rt_data; 
    data.accuracy_per_question = window.acc_data; 
    data.skipped = {}; 
    for ( let i = 0; i < trial.questions.length; i++) { 
      let question = trial.questions[i]; 
      let questionName = question.name;
      let answeredValue = window.answered[questionName]; 
      let wasSkipped; 
      if (answeredValue === false) { 
        wasSkipped = true; 
      } else {
        wasSkipped = false; 
      }
      data.skipped[questionName] = wasSkipped; 
    }


  //data.click_log = window.click_log;

//   // ================= SKIPPED THEN REANSWERED =================

// const answer_click_log = window.click_log || [];

// const firstClickTimes = {}; // q_index -> first click time

// answer_click_log.forEach(log => {
//   if (firstClickTimes[log.q_index] === undefined) {
//     firstClickTimes[log.q_index] = log.t_from_page_start;
//   }
// });

// const skippedThenReanswered = [];

// answer_click_log.forEach(log => {
//   const index = log.q_index;
//   const firstClickTime = firstClickTimes[index];

//   // only evaluate first click per question
//   if (log.t_from_page_start !== firstClickTime) return;

//   for (let higher = index + 1; higher < trial.questions.length; higher++) {
//     if (
//       firstClickTimes[higher] !== undefined &&
//       firstClickTimes[higher] < firstClickTime
//     ) {
//       skippedThenReanswered.push(log.qname);
//       break;
//     }
//   }
// });

// // EXPORT TO DATA (this is the key part)
// data.skipped_then_reanswered = skippedThenReanswered;
// data.skipped_then_reanswered_count = skippedThenReanswered.length;


    // ---- FLATTEN per-question RTs ----
if (data.rt_per_question) {
  for (let key in data.rt_per_question) {
    data["rt_" + key] = data.rt_per_question[key];  
  }
}

// ---- FLATTEN per-question accuracy ----
if (data.accuracy_per_question) {
  for (let key in data.accuracy_per_question) {
    data["acc_" + key] = data.accuracy_per_question[key];
  }
}

// ---- FLATTEN skipped flags ----
if (data.skipped) {
  for (let key in data.skipped) {
    data["skipped_" + key] = data.skipped[key]; 
  }
}

// ---- FLATTEN ASRS responses ----
if (data.trial_section === "asrsQs" && data.response) {
    for (const [key, value] of Object.entries(data.response)) {
        data[key] = value; 
    }
}
    };

  return trial;
}


// PARTICIPANT ID DISPLAY SCREEN ================================================================
// // Participants must provide this if they wish to withdraw their data. 

const display_id = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <p><strong>Your Participant ID is:</strong></p>
      <p style="font-size: 24px;">${subject_id}</p>
      <p>Please write this ID down for your records.</p>
      <p style = "max-width: 1000px; margin: 0 auto;"">If you wish to withdraw your data from this study or if something goes wrong, you must provide this unique participant identification code. As the study is conducted anonymously, we will be unable to identify or remove your data without this code.</p>
    `,
    choices: ["Continue"]
  };


// ADD CUSTOM LOGIC/COUNTERBALANCING AND PUSH ================================================================

const page1_trial = addSurveyLogic(page1_qs);
const page2_trial = addSurveyLogic(page2_qs);
const page3_trial = addSurveyLogic(page3_qs);
const page4_trial = addSurveyLogic(page4_qs);

orderRandomisation = jsPsych.randomization.shuffle([page1_trial, page2_trial, page3_trial]);


// INITIALISE TIMELINE ================================================================

var timeline = []


// INFOSHEET, CONSENT, INSTRUCTIONS ------------------------------------------------

timeline.push(infoConsent)
timeline.push(display_id)
timeline.push({ type: jsPsychFullscreen, fullscreen_mode: true })
timeline.push(instructions)


// // Task Pages ------------------------------------------------

timeline.push(...orderRandomisation)
timeline.push(page4_trial)
timeline.push(break_page) 


// // Demographics ------------------------------------------------
timeline.push(questionnaire_asrs_ina)
timeline.push(questionnaire_asrs_hyp)
timeline.push(demographics)


// // End Experiment ------------------------------------------------
timeline.push(debrief)
timeline.push(display_id)

// Save data via DataPipe -------
const save_csv = {
    type: jsPsychPipe,
    action: "save",
    experiment_id: "PDziWg9wxGbF",
    filename: `${subject_id}_full.csv`,
    data_string: ()=>jsPsych.data.get().csv()
  };

const save_summary_csv = {
    type: jsPsychPipe,
    action: "save",
    experiment_id: "PDziWg9wxGbF",
    filename: `${subject_id}_summary.csv`,
    data_string: ()=>jsPsych.data.get().filter({trial_section: "summary"}).csv()
  };

  const save_json = {
    type: jsPsychPipe,
    action: "save",
    experiment_id: "PDziWg9wxGbF",
    filename: `${subject_id}_full.json`,
    data_string: ()=>jsPsych.data.get().json()
  };

const save_data = [save_csv, save_summary_csv, save_json];

timeline.push(save_summary_trial)
timeline.push(...save_data)
timeline.push(end_test)
timeline.push({ type: jsPsychFullscreen, fullscreen_mode: false })


// RUN THE TIMELINE ================================================================
jsPsych.run(timeline);

    </script>
</html>
